using UnityEngine;
using System.Collections;
//using UnityEditor;
using System.Collections.Generic;
using System;
using Random = System.Random;

public class GridGenerator : MonoBehaviour {

	public Material trailMaterial;
	public float GridSize = 100;
	public float GridCount = 5;
	public GameObject Grid;
	public GameObject CubeTemplate;



	private List<GameObject> Cubes = new List<GameObject>();
	private Random rand = new Random();
	private const float SPEED = 2;

	private Vector3[] directions = new Vector3[6]{
		Vector3.up,
		Vector3.down,
		Vector3.left,
		Vector3.right,
		Vector3.forward,
		Vector3.back
	};

	// Use this for initialization
	void Start () {

		CreateGrid();
		//SaveGrid();

		CreateCubes();


	}

	float getRand(float from, float to){
		return (float) rand.NextDouble() * (to - from) + from;
	}

	void CreateCubes(){
		Vector3 position;
		Quaternion rotation;
		GameObject cubeChild;


		for (UInt16 i = 0; i < 50; i++){
			position = new Vector3(getRand(0f, GridSize), getRand(0f, GridSize), getRand(0f, GridSize));
			rotation = new Quaternion(0,0,0,0);
			// rotation = new Quaternion(getRand(0f,1) ,getRand(0f,1),getRand(0f,1) ,getRand(0f,1));
			cubeChild = (GameObject) Instantiate(CubeTemplate, position, rotation);
			cubeChild.rigidbody.velocity = GetRandomVelocity();
			Cubes.Add(cubeChild);
		}
	}

	Vector3 GetRandomVelocity(){
		return directions[rand.Next(directions.Length)] * SPEED;
	}

	void CreateGrid(){
		LineRenderer line;
		Color c1 = new Color();
		Color c2 = new Color();
		
		for (float u = 0; u <= GridSize; u += GridSize / GridCount){
			for (float v = 0; v <= GridSize; v += GridSize / GridCount){
				line = GetLineRenderer();
				line.SetPosition(0, new Vector3(u, v, 0));
				line.SetPosition(1, new Vector3(u, v, GridSize));
				
				c1 = Color.red;
				c2 = Color.blue;
				line.SetColors(c1, c2);
				
				line = GetLineRenderer();
				line.SetPosition(0, new Vector3(0, u, v));
				line.SetPosition(1, new Vector3(GridSize, u, v));
				
				c1 = Color.green;
				c2 = Color.blue;
				line.SetColors(c1, c2);
				
				

				line = GetLineRenderer();
				line.SetPosition(0, new Vector3(u, 0, v));
				line.SetPosition(1, new Vector3(u, GridSize, v));
				
				c1 = Color.blue;
				c2 = Color.red;
				line.SetColors(c1, c2);

				
				
				
			}
		}
		//AssetDatabase.CreateAsset(Grid, "Assets/AutogeneratedGrid");
		


	}

	void SaveGrid(GameObject Grid){
		//PrefabUtility.CreatePrefab("Assets/PrefabGrid.prefab", Grid, ReplacePrefabOptions.ConnectToPrefab);
	}
	
	// Update is called once per frame
	void Update () {
	
	}

	protected LineRenderer GetLineRenderer(){
		GameObject gameObject = new GameObject();		
		LineRenderer lineRenderer = gameObject.AddComponent<LineRenderer>();
		lineRenderer.material = new Material(Shader.Find("Particles/Additive"));
		//Color color = lineRenderer.material.color;
		//color.a = 0.0f;
		//lineRenderer.material.color = color;
		lineRenderer.SetWidth(0.08F, 0.08F);
		gameObject.transform.parent = Grid.transform;
		return lineRenderer;
	}
	/*
	protected GameObject GetTrailObject(Material myMaterial){

		LineRenderer lineRenderer = trail.AddComponent<LineRenderer>();
		lineRenderer.material = trailMaterial;
				
		lineRenderer.SetWidth(1.0F, 1.0F);
		lineRenderer.SetVertexCount(2);
		lineRenderer.useWorldSpace = true;
		return trail;
	}*/

	protected LineRenderer GetLineFromObject(GameObject lineObject){
		return lineObject.GetComponent<LineRenderer>();
	}

	void FixedUpdate(){


		foreach (GameObject cube in Cubes){

			Vector3 position = cube.rigidbody.position;
			Vector3 velocity = cube.rigidbody.velocity;
			/*
			if (position.x < 0) { position.x = 0; velocity.x = SPEED;}
			if (position.y < 0) { position.y = 0; velocity.y = SPEED;}
			if (position.z < 0) { position.z = 0; velocity.z = SPEED;}

			if (position.x > GridSize) { position.x = GridSize; velocity.x = SPEED;}
			if (position.y > GridSize) { position.y = GridSize; velocity.y = SPEED;}
			if (position.z > GridSize) { position.z = GridSize; velocity.z = SPEED;}
			*/

			if (getRand(0, 1000) > 999.9) velocity = GetRandomVelocity();

			if (position.x < 0 || position.x > GridSize) velocity.x *= -1 ;
			if (position.y < 0 || position.y > GridSize) velocity.y *= -1;
			if (position.z < 0 || position.z > GridSize) velocity.z *= -1;

			cube.rigidbody.velocity = velocity;
		}

	}

	Vector3 MixVectors(Vector3 a, Vector3 b){
		a.x *= b.x;
		a.y *= b.y;
		a.z *= b.z;
		return a;
	}
}
