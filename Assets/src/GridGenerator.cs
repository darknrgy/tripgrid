using UnityEngine;
using System.Collections;
//using UnityEditor;
using System.Collections.Generic;
using System;
using Random = System.Random;

public class GridGenerator : MonoBehaviour {

	public Material trailMaterial;
	public GameObject Grid;
	public GameObject CubeTemplate;

	public GameObject GlobalConfig;



	private List<GameObject> Cubes = new List<GameObject>();
	private Random rand = new Random();

	private Vector3[] directions = new Vector3[6]{
		Vector3.up,
		Vector3.down,
		Vector3.left,
		Vector3.right,
		Vector3.forward,
		Vector3.back
	};

	// Use this for initialization
	void Start () {

		CreateGrid();
		//SaveGrid();

		CreateCubes();
	}

	float getRand(float from, float to){
		return (float) rand.NextDouble() * (to - from) + from;
	}

	void CreateCubes(){
		Vector3 position;
		Quaternion rotation;
		GameObject cubeChild;

		float gridSize = Config.getF("WorldSize");

		for (UInt16 i = 0; i < Config.getI("NumberOfCubes"); i++){
//		for (UInt16 i = 0; i < 200; i++){
			position = new Vector3(getRand(0f, gridSize), getRand(0f, gridSize), getRand(0f, gridSize));
			rotation = new Quaternion(0,0,0,0);
			// rotation = new Quaternion(getRand(0f,1) ,getRand(0f,1),getRand(0f,1) ,getRand(0f,1));
			cubeChild = (GameObject) Instantiate(CubeTemplate, position, rotation);
			cubeChild.rigidbody.velocity = GetRandomVelocity();
			cubeChild.audio.pitch = getRand(0.3f, 1.0f);
			Cubes.Add(cubeChild);
		}
	}

	Vector3 GetRandomVelocity(){
		return directions[rand.Next(directions.Length)] * Config.getF("CubeSpeed");
	}

	void CreateGrid(){
		LineRenderer line;
		Color c1 = new Color();
		Color c2 = new Color();

		float gridSize = Config.getF("WorldSize");
		float gridCount = Config.getF("GridCount");
		
		for (float u = 0; u <= gridSize; u += gridSize / gridCount){
			for (float v = 0; v <= gridSize; v += gridSize / gridCount){
				line = GetLineRenderer();
				line.SetPosition(0, new Vector3(u, v, 0));
				line.SetPosition(1, new Vector3(u, v, gridSize));
				
				c1 = Color.red;
				c2 = Color.blue;
				line.SetColors(c1, c2);
				
				line = GetLineRenderer();
				line.SetPosition(0, new Vector3(0, u, v));
				line.SetPosition(1, new Vector3(gridSize, u, v));
				
				c1 = Color.green;
				c2 = Color.blue;
				line.SetColors(c1, c2);
				
				

				line = GetLineRenderer();
				line.SetPosition(0, new Vector3(u, 0, v));
				line.SetPosition(1, new Vector3(u, gridSize, v));
				
				c1 = Color.blue;
				c2 = Color.red;
				line.SetColors(c1, c2);

				
				
				
			}
		}
		//AssetDatabase.CreateAsset(Grid, "Assets/AutogeneratedGrid");
		


	}

	void SaveGrid(GameObject Grid){
		//PrefabUtility.CreatePrefab("Assets/PrefabGrid.prefab", Grid, ReplacePrefabOptions.ConnectToPrefab);
	}
	
	// Update is called once per frame
	void Update () {
	
	}

	protected LineRenderer GetLineRenderer(){
		GameObject gameObject = new GameObject();		
		LineRenderer lineRenderer = gameObject.AddComponent<LineRenderer>();
		lineRenderer.material = new Material(Shader.Find("Particles/Additive"));
		//Color color = lineRenderer.material.color;
		//color.a = 0.0f;
		//lineRenderer.material.color = color;
		lineRenderer.SetWidth(0.08F, 0.08F);
		gameObject.transform.parent = Grid.transform;
		return lineRenderer;
	}
	/*
	protected GameObject GetTrailObject(Material myMaterial){

		LineRenderer lineRenderer = trail.AddComponent<LineRenderer>();
		lineRenderer.material = trailMaterial;
				
		lineRenderer.SetWidth(1.0F, 1.0F);
		lineRenderer.SetVertexCount(2);
		lineRenderer.useWorldSpace = true;
		return trail;
	}*/

	protected LineRenderer GetLineFromObject(GameObject lineObject){
		return lineObject.GetComponent<LineRenderer>();
	}

	void FixedUpdate(){

		float worldSize = Config.getF("WorldSize");
		float bufferZone = Config.getF("BufferZone");

		float min = 0 - bufferZone;
		float max = worldSize + bufferZone;


		foreach (GameObject cube in Cubes){

			Vector3 position = cube.rigidbody.position;
			Vector3 velocity = cube.rigidbody.velocity;

			if (position.x < min) position.x = max;
			if (position.x > max) position.x = min;

			if (position.y < min) position.y = max;
			if (position.y > max) position.y = min;


			if (position.z < min) position.z = max;
			if (position.z > max) position.z = min;
			cube.rigidbody.position = position;

			if (getRand(0, 1000) > 999.9){
				velocity = GetRandomVelocity();
				cube.rigidbody.velocity = velocity;
			}

			/*
			if (position.x < 0 || position.x > worldSize) velocity.x *= -1 ;
			if (position.y < 0 || position.y > worldSize) velocity.y *= -1;
			if (position.z < 0 || position.z > worldSize) velocity.z *= -1;
			*/
			cube.rigidbody.velocity = velocity;

			
		}

	}

	Vector3 MixVectors(Vector3 a, Vector3 b){
		a.x *= b.x;
		a.y *= b.y;
		a.z *= b.z;
		return a;
	}
}
